"""
ドキュメント収集モジュール
Meta公式ドキュメント、業界知見などを収集
"""
import logging
import re
import time
from typing import Any
from datetime import datetime

import requests
from bs4 import BeautifulSoup

logger = logging.getLogger(__name__)


class DocumentCollector:
    """各種ソースからドキュメントを収集"""

    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
            "Accept-Language": "ja,en-US;q=0.9,en;q=0.8",
        })

    # =========================================================================
    # Meta公式ドキュメント収集
    # =========================================================================
    
    def collect_meta_best_practices(self) -> list[dict[str, Any]]:
        """Meta広告のベストプラクティスを収集"""
        documents = []
        
        # 主要なベストプラクティスのURL
        urls = [
            {
                "url": "https://www.facebook.com/business/help/212577612571937",
                "title": "広告の学習期間について",
                "category": "アルゴリズム",
            },
            {
                "url": "https://www.facebook.com/business/help/1619591734742116",
                "title": "広告予算の設定",
                "category": "予算",
            },
            {
                "url": "https://www.facebook.com/business/help/430291176997542",
                "title": "入札戦略について",
                "category": "入札",
            },
        ]
        
        for item in urls:
            try:
                content = self._fetch_and_parse(item["url"])
                if content:
                    documents.append({
                        "content": content,
                        "title": item["title"],
                        "url": item["url"],
                        "category": item["category"],
                        "source": "meta_official",
                        "collected_at": datetime.now().isoformat(),
                    })
                    logger.info(f"収集完了: {item['title']}")
                time.sleep(1)  # レート制限
            except Exception as e:
                logger.error(f"収集エラー ({item['title']}): {e}")
        
        return documents

    def collect_meta_marketing_api_docs(self) -> list[dict[str, Any]]:
        """Meta Marketing API ドキュメントを収集"""
        documents = []
        
        # APIドキュメントのキーセクション
        api_docs = [
            {
                "title": "Marketing API 概要",
                "content": """
Meta Marketing APIは、広告の作成、管理、レポーティングを自動化するためのAPIです。

主要な機能:
- キャンペーン、広告セット、広告の作成・更新・削除
- パフォーマンスデータの取得（Insights API）
- クリエイティブの管理
- オーディエンスの作成・管理

重要な概念:
- 広告アカウント（Ad Account）: 広告を管理する単位
- キャンペーン（Campaign）: 広告の目的を定義
- 広告セット（Ad Set）: ターゲティング、予算、スケジュールを定義
- 広告（Ad）: クリエイティブを含む実際の広告

APIバージョン:
- 最新バージョンを使用することを推奨
- 非推奨バージョンは2年後に廃止
""",
                "category": "API",
                "source": "meta_official",
            },
            {
                "title": "学習期間のベストプラクティス",
                "content": """
Meta広告の学習期間について:

学習期間とは:
- 広告配信システムが最適な配信先を学習する期間
- 通常7日間、または50コンバージョン程度

学習期間中のルール:
- 大幅な編集を避ける（予算、ターゲティング、クリエイティブ）
- 20%を超える予算変更は学習リセットを招く可能性
- 新しい広告セットは学習期間が必要

学習期間が長引く原因:
- 予算が少なすぎる
- ターゲットが狭すぎる
- コンバージョンイベントが少ない

推奨事項:
- 十分な予算を確保（目標CPA × 50 / 7日 以上）
- 広すぎず狭すぎないターゲティング
- 学習期間中は変更を控える
""",
                "category": "アルゴリズム",
                "source": "meta_official",
            },
            {
                "title": "予算最適化のベストプラクティス",
                "content": """
Meta広告の予算設定について:

キャンペーン予算最適化（CBO）:
- キャンペーンレベルで予算を設定
- Metaが広告セット間で自動配分
- パフォーマンスの良い広告セットに予算が集中

広告セット予算（ABO）:
- 広告セットごとに予算を設定
- 手動でコントロールしたい場合に使用
- テスト時に均等配分したい場合に有効

予算変更のルール:
- 急激な予算変更（20%超）は学習に影響
- 段階的に増やすことを推奨
- 大幅増額時はキャンペーン複製も検討

日予算 vs 通算予算:
- 日予算: 毎日の上限、柔軟な運用向け
- 通算予算: キャンペーン全体の上限、期間限定向け
""",
                "category": "予算",
                "source": "meta_official",
            },
            {
                "title": "入札戦略の選び方",
                "content": """
Meta広告の入札戦略:

最小コスト（Lowest Cost）:
- デフォルトの入札戦略
- 予算内で最大の成果を目指す
- CPAのコントロールは限定的

コスト上限（Cost Cap）:
- 目標CPAを設定
- その範囲内で最大成果を目指す
- 配信量が制限される可能性

入札上限（Bid Cap）:
- オークションごとの入札上限を設定
- 細かいコントロールが可能
- 設定が低すぎると配信されない

目標ROAS（ROAS Goal）:
- ECなど購入価値が明確な場合
- 目標ROASを設定
- 価値ベースの最適化

選び方:
- まずは最小コストで開始
- データが溜まったらコスト上限を検討
- ROASが重要ならROAS入札
""",
                "category": "入札",
                "source": "meta_official",
            },
            {
                "title": "Advantage+ ショッピングキャンペーン",
                "content": """
Advantage+ ショッピングキャンペーン（ASC）について:

概要:
- Meta AIが自動でターゲティング・クリエイティブを最適化
- EC事業者向けに設計されたキャンペーンタイプ
- 従来の手動設定より効率的な配信が可能

特徴:
- ターゲティングの自動化（手動設定不要）
- クリエイティブの自動最適化
- 商品カタログとの連携
- 既存顧客と新規顧客への最適配信

推奨条件:
- ECサイト・商品販売が目的
- 商品カタログが整備されている
- 十分なコンバージョンデータがある
- 週50件以上のコンバージョンが理想

注意点:
- ターゲティングの細かいコントロールができない
- 手動運用との併用を推奨
- 学習に時間がかかる場合がある
""",
                "category": "キャンペーン",
                "source": "meta_official",
            },
            {
                "title": "オーディエンスの種類と使い分け",
                "content": """
Meta広告のオーディエンス:

1. コアオーディエンス（興味関心ターゲティング）:
- 年齢、性別、地域
- 興味関心、行動
- デモグラフィック情報
- 新規獲得に使用

2. カスタムオーディエンス:
- ウェブサイト訪問者
- アプリユーザー
- 顧客リスト（メール、電話番号）
- 動画視聴者
- リターゲティングに使用

3. 類似オーディエンス（Lookalike）:
- ソースオーディエンスに似た人を発見
- 1%〜10%の範囲で設定
- 1%が最も類似度高い
- 新規拡大に使用

使い分け:
- 新規獲得: 興味関心 + 類似1-3%
- リタゲ: カスタム（訪問者、離脱ユーザー）
- 拡大フェーズ: 類似3-5%
- ブランド認知: 広めの興味関心

Advantage+ オーディエンス:
- Meta AIが自動でターゲティング
- 手動設定よりパフォーマンスが良い場合も
- 十分なデータがある場合に有効
""",
                "category": "ターゲティング",
                "source": "meta_official",
            },
            {
                "title": "広告クリエイティブのベストプラクティス",
                "content": """
Meta広告クリエイティブのガイドライン:

画像広告:
- 推奨サイズ: 1080x1080（フィード）、1080x1920（ストーリーズ）
- テキスト20%以下を推奨（以前のルールは撤廃されたが、少ない方が効果的）
- 高解像度の画像を使用
- 明るく目を引くビジュアル

動画広告:
- 最初の3秒で注目を集める
- 音声なしでも伝わる設計（字幕推奨）
- モバイルファースト（縦型9:16推奨）
- 15秒以内が効果的

リール広告:
- 縦型フルスクリーン（9:16）
- トレンドの音楽・効果音を活用
- UGC風のナチュラルな表現
- 広告感を出しすぎない

カルーセル広告:
- 2〜10枚の画像・動画
- ストーリー性を持たせる
- 最初のカードが最重要
- 商品一覧の展示に有効

A/Bテスト:
- 訴求軸の異なるクリエイティブを用意
- 1広告セットに3〜6クリエイティブ
- 勝者が決まったら入れ替え
""",
                "category": "クリエイティブ",
                "source": "meta_official",
            },
            {
                "title": "MetaピクセルとコンバージョンAPI",
                "content": """
計測の最適化:

Metaピクセル:
- ブラウザベースの計測
- JavaScriptタグをサイトに設置
- プライバシー制限の影響を受ける
- Safari/iOSでの制限あり

コンバージョンAPI（CAPI）:
- サーバーサイドの計測
- プライバシー制限を回避
- より正確な計測が可能
- ピクセルとの併用を推奨

推奨設定:
1. ピクセルとCAPIの両方を設置
2. 重複排除を有効化
3. 主要イベントを設定（購入、カート追加、等）
4. イベントマッチクオリティを監視

イベント優先度:
- 最大8イベントを設定可能
- 購入が最優先
- 次にカート追加、登録、等

アグリゲートイベント計測:
- iOS14.5以降の対応
- ドメイン認証が必要
- イベントの優先順位を設定
""",
                "category": "計測",
                "source": "meta_official",
            },
            {
                "title": "配信面（プレースメント）の選び方",
                "content": """
Meta広告の配信面:

Advantage+ プレースメント（自動配置）:
- Meta推奨
- AIが最適な配信面を自動選択
- 手動より効率的なことが多い

手動プレースメント:
- Facebookフィード
- Instagramフィード
- Instagramストーリーズ
- Instagramリール
- Facebook Marketplace
- Messenger
- Audience Network

使い分け:
- 基本は自動配置を推奨
- 特定の配信面だけで出したい場合は手動
- Instagramのみ、などのケースで有効

配信面別の特徴:
- フィード: 幅広いリーチ、情報量多め
- ストーリーズ: 没入感高い、縦型推奨
- リール: 若年層、エンタメ性
- Marketplace: 購買意欲高いユーザー

注意点:
- 配信面を絞ると配信量が減少
- CPM/CPCが上がる可能性
- テスト期間は広めに設定を推奨
""",
                "category": "配信",
                "source": "meta_official",
            },
            {
                "title": "アカウント構造のベストプラクティス",
                "content": """
Meta広告のアカウント構造:

推奨構造（シンプル化）:
- キャンペーン数を絞る
- 広告セットを統合
- 1広告セットあたり3-6クリエイティブ
- Metaの機械学習が効率よく動く

なぜシンプルが良いか:
- 予算の分散を防ぐ
- 学習データが集約される
- 管理工数の削減
- 自動最適化が効きやすい

キャンペーン分割の基準:
- 目的が異なる場合（認知/購入）
- 予算を明確に分けたい場合
- ABテストする場合

広告セット分割の基準:
- リタゲ vs 新規で分ける
- 地域で分ける（国別等）
- 予算配分を手動コントロールしたい場合

避けるべき構造:
- 少額予算を多数のキャンペーンに分散
- 類似ターゲティングの広告セットを複数
- 1広告セットに1クリエイティブだけ
""",
                "category": "アカウント構造",
                "source": "meta_official",
            },
            {
                "title": "キャンペーン目的の選び方",
                "content": """
Meta広告のキャンペーン目的:

認知:
- ブランド認知度
- リーチ
- 目的: 最大限の人に見せる

トラフィック:
- ウェブサイトへの誘導
- ランディングページビュー最適化も可能
- 目的: サイトに来てもらう

エンゲージメント:
- 投稿へのいいね、コメント、シェア
- Instagramフォロワー獲得
- 目的: 反応を得る

リード:
- リード獲得フォーム
- インスタントフォーム
- 目的: 見込み客情報の取得

アプリ:
- アプリインストール
- アプリ内イベント
- 目的: アプリの普及

売上:
- コンバージョン
- カタログ販売
- 目的: 購入・申込

選び方のポイント:
- 最終ゴールに近い目的を選ぶ
- 認知→購入のファネルを意識
- 十分なデータがある目的を選ぶ
""",
                "category": "キャンペーン",
                "source": "meta_official",
            },
            {
                "title": "フリークエンシーとリーチ管理",
                "content": """
フリークエンシー（広告接触回数）の管理:

フリークエンシーとは:
- 同じユーザーへの広告表示回数
- 高すぎると「広告疲れ」を招く
- 低すぎると記憶に残らない

目安:
- 認知目的: 1.5〜3回/週
- 購入目的: 3〜7回/週
- リタゲ: 7〜15回/週

フリークエンシーが高い場合:
- ターゲットが狭すぎる
- 予算に対してオーディエンスが小さい
- クリエイティブの疲弊

対策:
- ターゲティングを広げる
- 予算を下げる
- クリエイティブを入れ替える
- 新しいオーディエンスを追加

リーチ&フリークエンシーキャンペーン:
- 事前に到達人数と頻度を設定
- 認知目的で使用
- 予約型（費用が固定）
""",
                "category": "配信",
                "source": "meta_official",
            },
            {
                "title": "A/Bテストの設計",
                "content": """
Meta広告のA/Bテスト:

テスト機能:
- 広告マネージャーのA/Bテスト機能
- オーディエンスを自動で分割
- 統計的有意差を判定

テストできる要素:
- クリエイティブ（画像、動画、コピー）
- オーディエンス（ターゲティング）
- 配置（プレースメント）
- 配信最適化

テスト設計のポイント:
1. 一度に1要素だけ変える
2. 十分な予算を確保（信頼性のため）
3. テスト期間は最低7日
4. 勝者を明確に定義

予算の目安:
- 目標CPA × 100 以上を推奨
- 少なすぎると有意差が出ない
- テスト期間中は変更しない

結果の見方:
- 統計的有意差があるか
- リフト率（改善率）
- コスト効率
""",
                "category": "テスト",
                "source": "meta_official",
            },
            {
                "title": "広告ポリシーと審査",
                "content": """
Meta広告の審査とポリシー:

審査プロセス:
- 広告作成後、自動審査
- 通常24時間以内に完了
- AI + 人間によるレビュー

よくある否認理由:
1. 誇大表現（「絶対」「100%」等）
2. Before/After画像（非現実的な結果）
3. 個人属性への言及（「太っている方へ」等）
4. 禁止コンテンツ（タバコ、武器等）
5. ランディングページの問題

審査を通すコツ:
- ポリシーを事前に確認
- 誇大表現を避ける
- ユーザー属性を断定しない
- LPと広告の整合性を保つ

否認された場合:
- 理由を確認
- 修正して再審査
- 異議申し立ても可能

特別な業界:
- 金融、薬、アルコール等は追加ルール
- 事前の認証が必要な場合も
""",
                "category": "ポリシー",
                "source": "meta_official",
            },
        ]
        
        for doc in api_docs:
            documents.append({
                "content": doc["content"],
                "title": doc["title"],
                "url": None,
                "category": doc["category"],
                "source": doc["source"],
                "collected_at": datetime.now().isoformat(),
            })
        
        logger.info(f"Meta APIドキュメント {len(documents)}件を収集")
        return documents

    # =========================================================================
    # 業界知見収集
    # =========================================================================
    
    def collect_industry_knowledge(self) -> list[dict[str, Any]]:
        """業界知見（通説・ベストプラクティス）を収集"""
        documents = []
        
        # 運用者の間で知られている知見
        knowledge_items = [
            {
                "title": "20%ルール（予算変更）",
                "content": """
予算変更の20%ルール:

背景:
- Meta広告は機械学習で配信を最適化している
- 急激な予算変更は学習をリセットする可能性がある

ルール:
- 予算変更は1日20%以内に抑える
- 例: 10万円 → 12万円 はOK
- 例: 10万円 → 20万円 は学習リセットのリスク

大幅に予算を増やしたい場合:
1. 段階的に増やす（20%ずつ数日かけて）
2. キャンペーンを複製して新規で高予算を設定
3. 別の広告セットを追加

注意点:
- 公式に明記されたルールではなく通説
- 案件や状況によって影響度は異なる
- 学習が安定している場合は影響が少ない場合も

参考:
- https://note.com/juchida/n/n46234a38e018
""",
                "category": "予算",
                "source": "industry",
            },
            {
                "title": "CPAからの逆算思考",
                "content": """
CPA達成可能性の判断方法:

基本式:
CPA = CPC ÷ CVR
（または CPA = CPM ÷ CTR ÷ CVR × 1000）

逆算の例:
- 目標CPA: 5,000円
- 現在のCVR: 2%
- → 必要なCPC: 100円以下

判断フロー:
1. 目標CPAと現在CVRから必要CPCを算出
2. 現在のCPCと比較
3. 現在CPC > 必要CPC なら改善必要
4. 改善余地があるか判断

改善の方向性:
- CPC高い → クリエイティブ改善、ターゲティング見直し
- CVR低い → LP改善、オファー見直し、記事LP追加
- 両方問題 → 根本的な見直しが必要

重要な視点:
- 単純に「CPAが高いから停止」ではない
- どこに問題があるか分解して考える
- 改善余地があるなら継続して改善
""",
                "category": "入札",
                "source": "industry",
            },
            {
                "title": "クリエイティブの訴求軸",
                "content": """
クリエイティブの訴求軸を分けることの重要性:

問題:
- 同じ訴求のクリエイティブを複数並べても意味がない
- 同じ層にしかリーチできない
- 予算の無駄遣い

訴求軸の種類:
1. 価格訴求: 「今だけ0円」「初回500円」「90%OFF」
2. 機能訴求: 「業界最速」「特許技術」「効果実証済み」
3. 情緒訴求: 「理想の自分に」「もう悩まない」
4. 実績訴求: 「10万人が利用」「満足度98%」
5. 権威訴求: 「医師監修」「専門家推奨」
6. 恐怖訴求: 「このままでは...」「知らないと損」
7. クチコミ訴求: 「利用者の声」「Before/After」

ベストプラクティス:
- 異なる訴求軸で3-5パターン用意
- 各訴求で反応する層が異なる
- テストして勝者を見つける
- 勝者の訴求軸をさらに深掘り
""",
                "category": "クリエイティブ",
                "source": "industry",
            },
            {
                "title": "記事LPの効果と使い方",
                "content": """
記事LP（記事型ランディングページ）について:

記事LPとは:
- 広告→記事→LPの導線
- 記事で教育・信頼構築してからLPへ

メリット:
- CVRが上がることが多い
- CPAが下がる傾向
- 広告感が薄れ、自然な導線に
- 情報量が多く、高額商材に有効

デメリット:
- 離脱ポイントが増える
- 記事の質が重要
- 制作コストがかかる

使い分け:
- 低単価商材 → 直LP（記事なし）
- 高単価商材 → 記事LP推奨
- 信頼が必要な商材 → 記事LP推奨
- 衝動買い商材 → 直LP

記事LPのポイント:
- ストーリー性を持たせる
- 読者の悩みに共感
- 解決策として商品を紹介
- スムーズにLPへ誘導
""",
                "category": "クリエイティブ",
                "source": "industry",
            },
            {
                "title": "キャンペーン構造のパターン",
                "content": """
Meta広告のキャンペーン構造パターン:

パターン1: シンプル構造
- 1キャンペーン / 1広告セット / 複数広告
- 少額テスト向け
- 管理が楽

パターン2: 広告セット分割
- 1キャンペーン / 複数広告セット / 各複数広告
- ターゲティング別にテスト
- 予算配分を手動コントロール

パターン3: キャンペーン分割
- 複数キャンペーン / 各1広告セット / 各複数広告
- 目的別に分ける
- 大規模運用向け

予算を大きくする場合:
- 1つのキャンペーンで100万円/日は可能
- ただし同じオーディエンスに偏る
- キャンペーン分割で異なる最適化を期待
- ABテスト機能でオーディエンス分離も有効

tCPA（目標CPA）設定:
- 大予算の場合に有効
- Metaが目標CPA内で獲得しようとする
- 少額では効果が薄い
""",
                "category": "アルゴリズム",
                "source": "industry",
            },
        ]
        
        for item in knowledge_items:
            documents.append({
                "content": item["content"],
                "title": item["title"],
                "url": None,
                "category": item["category"],
                "source": item["source"],
                "collected_at": datetime.now().isoformat(),
            })
        
        logger.info(f"業界知見 {len(documents)}件を収集")
        return documents

    # =========================================================================
    # ユーティリティ
    # =========================================================================
    
    def _fetch_and_parse(self, url: str) -> str | None:
        """URLからコンテンツを取得してパース"""
        try:
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, "lxml")
            
            # 不要な要素を削除
            for tag in soup(["script", "style", "nav", "footer", "header"]):
                tag.decompose()
            
            # メインコンテンツを抽出
            main = soup.find("main") or soup.find("article") or soup.find("body")
            if main:
                text = main.get_text(separator="\n", strip=True)
                # 複数の空行を1つに
                text = re.sub(r"\n{3,}", "\n\n", text)
                return text[:5000]  # 最大5000文字
            
            return None
        except Exception as e:
            logger.error(f"Fetch error for {url}: {e}")
            return None

    def collect_all(self) -> dict[str, list[dict]]:
        """全てのソースからドキュメントを収集"""
        return {
            "meta_official": self.collect_meta_marketing_api_docs(),
            "industry": self.collect_industry_knowledge(),
        }


